{"name":"前端","slug":"前端","count":6,"postlist":[{"title":"JS防抖动与节流","slug":"JS防抖动与节流","date":"2018-06-07T01:01:30.000Z","updated":"2018-06-07T05:59:23.250Z","comments":true,"path":"api/articles/JS防抖动与节流.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于自己在之前的个人项目中涉及到JS防抖动的问题,所以我上网查询了相关资料,顺便谈谈自己对防抖动与节流的总结吧</p>\n<blockquote>\n<p>应用场景</p>\n</blockquote>\n<ol>\n<li>window的resize，scroll事件</li>\n<li>拖拽过程中的 mousemove事件</li>\n<li>文字输入过程中的keyup</li>\n<li>连续快速点击等事件</li>\n</ol>\n<p>这些事件会在短时间内多次触发,十分影响浏览器性能而且也不利于以后维护。</p>\n<h2 id=\"防抖动-debounce\"><a href=\"#防抖动-debounce\" class=\"headerlink\" title=\"防抖动(debounce)\"></a>防抖动(debounce)</h2><blockquote>\n<p>原理</p>\n</blockquote>\n<p>在调用事件之前,设置一个计时器,在规定时间之后才会去调用。<br>而在规定时间内再次执行这个调用事件的动作的话,就会把原来的定时器clear掉,再重新设置一个定时器。<br>与函数节流不同,防抖动只有最后一次操作能被触发</p>\n<blockquote>\n<p>具体代码实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将会包装事件的 debounce 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 维护一个 timer</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      fn.apply(context, args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当用户滚动时被调用的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'You are scrolling!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 debounce 中包装我们的函数，过 2 秒触发一次</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> elem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\">elem.addEventListener(<span class=\"string\">'scroll'</span>, debounce(foo, <span class=\"number\">2000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数节流-throttle\"><a href=\"#函数节流-throttle\" class=\"headerlink\" title=\"函数节流(throttle)\"></a>函数节流(throttle)</h2><p>节流是另一种处理类似问题的解决方法。<br><code>节流函数允许一个函数在规定的时间内只执行一次。</code></p>\n<p>它和防抖动最大的区别就是，<code>节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。(每隔一段时间执行一次)</code></p>\n<p>比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流阀技术来实现。</p>\n<blockquote>\n<p>原理</p>\n</blockquote>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到delay秒后，定时器执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<blockquote>\n<p>具体代码实现</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = fucntion(func,delay)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> funtion()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!timer)&#123;</span><br><span class=\"line\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                func.apply(context,args);</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;,delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上有错误的地方,或者不懂的地方,欢迎来我的微博给我留言。</p>\n<p>参考链接 <a href=\"https://blog.csdn.net/crystal6918/article/details/62236730\" target=\"_blank\" rel=\"noopener\">JS防抖动与节流</a></p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言由于自己在之前的个人项目中涉及到JS防抖动的问题,所以我上网查询了相关资料,顺便谈谈自己对防抖动与节流的总结吧应用场景window的resize，scroll事件拖拽过程中的 mousemove事件文字输入过程中的keyup连续快速点击等事件这些事件会在短时间内多次触发,十分","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/tags/JavaScript.json"}]},{"title":"HTTP随记","slug":"HTTP随记","date":"2018-11-23T01:01:30.000Z","updated":"2018-12-04T02:23:20.468Z","comments":true,"path":"api/articles/HTTP随记.json","excerpt":"","keywords":null,"cover":"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/request.png","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>基础知识回顾http篇</p>\n<h3 id=\"1-http协议基础及发展历史\"><a href=\"#1-http协议基础及发展历史\" class=\"headerlink\" title=\"1.http协议基础及发展历史\"></a>1.http协议基础及发展历史</h3><h4 id=\"1-1http发展历史\"><a href=\"#1-1http发展历史\" class=\"headerlink\" title=\"1.1http发展历史\"></a>1.1http发展历史</h4><h5 id=\"http-0-9\"><a href=\"#http-0-9\" class=\"headerlink\" title=\"http 0.9\"></a>http 0.9</h5><ol>\n<li>只有一个命令（GET）</li>\n<li>没有header等描述数据的信息</li>\n<li>服务器发送完毕,就关闭TCP连接</li>\n</ol>\n<h5 id=\"http-1-0\"><a href=\"#http-1-0\" class=\"headerlink\" title=\"http 1.0\"></a>http 1.0</h5><ol>\n<li>增加了很多命令(POST,PUT等)</li>\n<li>增加status code 和 header</li>\n<li>多字符集支持、多部分发送、权限、缓存等</li>\n</ol>\n<h5 id=\"http-1-1\"><a href=\"#http-1-1\" class=\"headerlink\" title=\"http 1.1\"></a>http 1.1</h5><ol>\n<li>支持了持久连接(http请求后可以不关闭tcp连接)</li>\n<li>Pipeline(在同一个tcp连接里可以支持多个http请求)</li>\n<li>增加host和其他一些命令</li>\n</ol>\n<h5 id=\"http-2-0-暂未普及\"><a href=\"#http-2-0-暂未普及\" class=\"headerlink\" title=\"http 2.0(暂未普及)\"></a>http 2.0(暂未普及)</h5><ol>\n<li>所有数据以二进制传输</li>\n<li>同一个连接里面发送多个请求不在需要按照顺序来</li>\n<li>头信息压缩以及推送等提高效率的功能(推送:服务器端主动向前端推送数据)</li>\n</ol>\n<h4 id=\"1-2http协议基础\"><a href=\"#1-2http协议基础\" class=\"headerlink\" title=\"1.2http协议基础\"></a>1.2http协议基础</h4><p><img src=\"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/request.png\" alt=\"requestProcess\"></p>\n<p><img src=\"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/model.png\" alt=\"model\"></p>\n<ol>\n<li>低三层<br>a. 物理层: 物理层主要作用是定义物理设备如何传输数据(网线,网卡,电脑等硬件)<br>b. 数据链路层: 数据链路层在通信的实体间建立数据链路链接<br>c. 网络层: 网络层为数据在节点之间传输创建逻辑链路(自己电脑与服务器间)</li>\n<li>传输层 (TCP IP)</li>\n<li>应用层（HTTP）</li>\n</ol>\n<h3 id=\"2-http的三次握手\"><a href=\"#2-http的三次握手\" class=\"headerlink\" title=\"2.http的三次握手\"></a>2.http的三次握手</h3><p><img src=\"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/shakehans.png\" alt=\"request\"><br>请求过程: 用户在客户端发起http请求 然后 建立tcp 连接 ，把请求发送给服务器端</p>\n<p><img src=\"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/shakehans1.png\" alt=\"shakehands\"></p>\n<ol>\n<li>客户端发送一个我要创建连接的数据包</li>\n<li>服务器端开放一个端口并返回给客户端带有标识的数据包</li>\n<li>客户端表示服务器端允许连接后再发送一个带有标识的数据包</li>\n</ol>\n<blockquote>\n<p>3次握手的目的</p>\n</blockquote>\n<p>防止服务器端开启一些无用的连接(规避网络原因等引起无用的一些端口开销和连接)</p>\n<h3 id=\"3-URI-URL-URN\"><a href=\"#3-URI-URL-URN\" class=\"headerlink\" title=\"3.URI URL URN\"></a>3.URI URL URN</h3><ol>\n<li>URI: 统一资源标识符（Uniform Resource Identifier，或URI)  用来唯一标识互联网上的信息资源</li>\n<li><p>URL：统一资源定位符（Uniform Resource Locator）http  ftp 等都是url</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</span><br><span class=\"line\">b. 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</span><br><span class=\"line\">c. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</span><br><span class=\"line\">d. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</span><br><span class=\"line\">e. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</span><br><span class=\"line\">f.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</span><br><span class=\"line\">g.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>URN：永久统一资源定位符 在资源移动之后还能找到</p>\n</li>\n</ol>\n<h3 id=\"4-Cache-Control\"><a href=\"#4-Cache-Control\" class=\"headerlink\" title=\"4.Cache-Control\"></a>4.Cache-Control</h3><ol>\n<li>可缓冲性<br><code>Public</code>  http经过任何地方都可以缓存(服务器,代理服务器等)<br><code>Private</code> 发起请求的浏览器才可以进行缓存<br><code>No-cache</code> 可以服务器同意后才能使用缓存</li>\n<li>到期<br><code>Max-age=&lt;seconds&gt;</code>  缓存多少秒过期<br><code>s-maxage=&lt;seconds&gt;</code> 仅在代理服务器上设置的缓存到期时间<br><code>max-stale=&lt;seconds&gt;</code> 在设置的缓存过期时间后还能使用过期的缓存</li>\n<li>重新验证<br><code>Must-revalidate</code>  在缓存过期之后必须去服务器重新请求<br><code>Proxy-revalidate</code>  缓存服务器使用的</li>\n<li>其他<br><code>No-store</code>  本地和服务器都不能存储这个缓存<br><code>No-transform</code> 代理服务器用</li>\n</ol>\n<h3 id=\"5-资源验证-用于设置了no-cache的验证\"><a href=\"#5-资源验证-用于设置了no-cache的验证\" class=\"headerlink\" title=\"5.资源验证(用于设置了no-cache的验证)\"></a>5.资源验证(用于设置了no-cache的验证)</h3><blockquote>\n<p>验证头</p>\n<ol>\n<li>Last-Modified<br>上次修改时间<br>服务器端 使用<code>If-Modified-Since</code>或者<code>If-Unmodified-Since</code><br>对比上次修改时间以验证资源是否需要更新</li>\n<li>Etag<br>数据签名<br>服务器端 使用<code>If-Match</code>或者<code>If-Non-Match</code><br>对比资源的签名 判断是否使用缓存</li>\n</ol>\n</blockquote>\n<h3 id=\"6-Cookie\"><a href=\"#6-Cookie\" class=\"headerlink\" title=\"6.Cookie\"></a>6.Cookie</h3><p>通过Set-Cookie字段设置, 下次请求会自动带上, 以键值对,可以设置多个, <code>Cookie不等于session</code><br><code>属性</code></p>\n<ol>\n<li>Max-age(设置一个过期的时间, 比如几秒)和expires(设置一个具体的过期时间点)设置过期时间</li>\n<li>Secure只在https的时候发送</li>\n<li>HttpOnly无法通过documen.cookie访问(无法通过js获取)</li>\n</ol>\n<h3 id=\"7-http长链接-Connection-keep-alive-请求后不关闭tcp链接\"><a href=\"#7-http长链接-Connection-keep-alive-请求后不关闭tcp链接\" class=\"headerlink\" title=\"7.http长链接(Connection:keep-alive,请求后不关闭tcp链接)\"></a>7.http长链接(Connection:keep-alive,请求后不关闭tcp链接)</h3><ol>\n<li>设置后, 多个http请求共用一个tcp链接(chorme为最多支持6个并发的http请求)</li>\n<li>http2.0 支持一个tcp链接 可以多个http请求</li>\n</ol>\n<h3 id=\"8-数据协商-客服端发送请求-表明想要什么类型的数据\"><a href=\"#8-数据协商-客服端发送请求-表明想要什么类型的数据\" class=\"headerlink\" title=\"8.数据协商(客服端发送请求,表明想要什么类型的数据)\"></a>8.数据协商(客服端发送请求,表明想要什么类型的数据)</h3><blockquote>\n<p>请求</p>\n</blockquote>\n<ol>\n<li>Accept 想要的数据类型</li>\n<li>ACCEPT-Encoding  编码方式(压缩方式, gzip,deflate,br)</li>\n<li>Accept-Language  语言</li>\n<li>User-Agent  移动端或者PC端</li>\n<li>Content-Type  传送的数据格式</li>\n<li>…</li>\n</ol>\n<blockquote>\n<p>返回</p>\n</blockquote>\n<ol>\n<li>Content  服务器端返回的数据类型</li>\n<li>Content-Type  返回的数据格式</li>\n<li>Content-Encoding  返回的编码方式(压缩方式, gzip,deflate,br)</li>\n<li>Content-Language  返回的语言</li>\n<li>X-Content-Type-Options: nosniff   告诉浏览器不要猜测返回数据类型</li>\n<li>…</li>\n</ol>\n<p><img src=\"https://github.com/Cxuyang/hexo-demo/blob/master/source/img/http/accept-content.png\" alt=\"accept-content\"></p>\n<h3 id=\"9-Redirect-重定向\"><a href=\"#9-Redirect-重定向\" class=\"headerlink\" title=\"9.Redirect(重定向)\"></a>9.Redirect(重定向)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (request.url === <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// stateCode(状态码): 301-永久重定向,清除浏览器缓存消失; 302-每次都会进入浏览器进行跳转</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> stateCode = <span class=\"string\">'301'</span></span><br><span class=\"line\">  response.writeHead(stateCode. &#123;</span><br><span class=\"line\">    <span class=\"string\">'Location'</span>: <span class=\"string\">'/new'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  response.end(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-Content-Security-Policy-内容安全策略\"><a href=\"#10-Content-Security-Policy-内容安全策略\" class=\"headerlink\" title=\"10.Content-Security-Policy(内容安全策略)\"></a>10.Content-Security-Policy(内容安全策略)</h3><ol>\n<li>限制资源获取</li>\n<li>报告资源获取越权</li>\n</ol>\n<blockquote>\n<p>限制方式</p>\n</blockquote>\n<ol>\n<li>default-src 限制全局</li>\n<li>限制指定资源类型(connect-src, img-srcm, script-src, style-src…)</li>\n</ol>\n<h3 id=\"以后再补充\"><a href=\"#以后再补充\" class=\"headerlink\" title=\"以后再补充\"></a>以后再补充</h3><h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言基础知识回顾http篇1.http协议基础及发展历史1.1http发展历史http 0.9只有一个命令（GET）没有header等描述数据的信息服务器发送完毕,就关闭TCP连接http 1.0增加了很多命令(POST,PUT等)增加status code 和 header多字","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"http","slug":"http","count":1,"path":"api/tags/http.json"},{"name":"前端","slug":"前端","count":2,"path":"api/tags/前端.json"},{"name":"Nginx","slug":"Nginx","count":2,"path":"api/tags/Nginx.json"}]},{"title":"JS模块化规范","slug":"JS模块化规范","date":"2018-02-10T01:01:30.000Z","updated":"2018-06-25T02:46:38.941Z","comments":true,"path":"api/articles/JS模块化规范.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>ES6模块化杂谈</p>\n</blockquote>\n<p>从react的学习回过头来看ES6的模块化<br>ES6中自带模块化机制，告别了sea.js和require.js<br>类似于<code>对象的解构赋值</code>.</p>\n<p>module.js和es6.js位于同一目录下。</p>\n<h3 id=\"module-js\"><a href=\"#module-js\" class=\"headerlink\" title=\"module.js\"></a>module.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> name = <span class=\"string\">'cxy'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">text</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"es6-js\"><a href=\"#es6-js\" class=\"headerlink\" title=\"es6.js\"></a>es6.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;name, text&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name)</span><br><span class=\"line\">text()</span><br></pre></td></tr></table></figure>\n<p>引入module.js中所有内容<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> mod <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JS模块化规范\"><a href=\"#JS模块化规范\" class=\"headerlink\" title=\"JS模块化规范\"></a>JS模块化规范</h2><blockquote>\n<p>JS模块化规范</p>\n</blockquote>\n<p>学习node.js的过程中回头来谈谈自己对于JS模块化规范的总结(总结比较简单,详情可看我提供的资料或者自行查询)。</p>\n<h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h3><p>为了弥补<code>JavaScript</code>相关缺陷，以及为了规范其标准，以达到像Python、Ruby、和Java具备开发大型应用的基础能力。</p>\n<blockquote>\n<p>CommonJS模块化规范</p>\n</blockquote>\n<p>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>然后，就可以调用模块提供的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>);</span><br><span class=\"line\">math.add(<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}</p>\n<p>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。</p>\n<h3 id=\"AMD规范-异步模块定义\"><a href=\"#AMD规范-异步模块定义\" class=\"headerlink\" title=\"AMD规范(异步模块定义)\"></a>AMD规范(异步模块定义)</h3><p>CommonJS模块规范的延伸。因为之前CommonJS模块化引入方法是<code>同步</code>的,不完全适合前端的应用场景,因此AMD规范(异步模块定义)便有了更好的运用。</p>\n<blockquote>\n<p>AMD模块化规范</p>\n</blockquote>\n<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"built_in\">module</span>], callback);</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'math'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\">　math.add(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。目前，主要有两个Javascript库实现了AMD规范：<code>require.js</code>和<code>curl.js</code>。</p>\n<h3 id=\"CMD规范\"><a href=\"#CMD规范\" class=\"headerlink\" title=\"CMD规范\"></a>CMD规范</h3><p>CMD规范由国内的玉伯提出,与AMD规范的主要区别在于定义模块和依赖引入的部分.</p>\n<p>AMD需要在声明模块的时候指定所有依赖<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'dep1'</span>, <span class=\"string\">'dep2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dep1, dep2</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>与AMD模块规范相比,CMD模块更接近于Node对CommonJS规范的定义:<code>define(factory)</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// code</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>require, exports, module通过形参传递给模块,在需要依赖模块时,再调用require()引入模块。</p>\n<h2 id=\"兼容多种模块规范\"><a href=\"#兼容多种模块规范\" class=\"headerlink\" title=\"兼容多种模块规范\"></a>兼容多种模块规范</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, definition</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 检测上下文环境是否为AMD或CMD</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> hasDefine = <span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 检查上下文环境是否为Node</span></span><br><span class=\"line\">    hasExports = <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasDefine) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// AMD环境或CMD环境</span></span><br><span class=\"line\">    define(definition);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hasExports) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义为普通Node模块</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = definition();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将模块的执行结果挂在window变量中，在浏览器中this指向window对象，在node中为global</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>[name] = definition();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"string\">'hello'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hello;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p>《深入浅出node.js》</p>\n<p><a href=\"https://www.cnblogs.com/chenguangliang/p/5856701.html\" target=\"_blank\" rel=\"noopener\">JS模块化规范</a></p>\n</blockquote>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言ES6模块化杂谈从react的学习回过头来看ES6的模块化<br>ES6中自带模块化机制，告别了sea.js和require.js<br>类似于对象的解构赋值.module.js和es6.js位于同一目录下。module.js1<br>2<br>3<br>4<br>expor","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/tags/JavaScript.json"},{"name":"ES6","slug":"ES6","count":1,"path":"api/tags/ES6.json"},{"name":"模块化","slug":"模块化","count":1,"path":"api/tags/模块化.json"}]},{"title":"文件上传随记","slug":"file_upload","date":"2018-04-02T02:01:30.000Z","updated":"2018-04-25T03:14:42.179Z","comments":true,"path":"api/articles/file_upload.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>多文件上传</p>\n</blockquote>\n<p>项目之前采用的是element-ui官方的文件上传组件，但在实际开发的过程中，发现该组件虽然能够选择多个文件进行上传，但是却不能同时上传(文件只能发送一次http请求，上传一次)。<br>最后采用 POST FormData的方式进行上传。</p>\n<h2 id=\"Fetch-FormData\"><a href=\"#Fetch-FormData\" class=\"headerlink\" title=\"Fetch FormData\"></a>Fetch FormData</h2><p>首先获取文件对象的数组(多文件的情况下，单文件就不需要遍历添加了),<br>随后实例FormData对象，将文件对象数组添加到FormData对象中，<br>再以fetch body属性上传就行了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fileData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">filesArray.map(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span>&#123;</span><br><span class=\"line\">    fileData.append(<span class=\"string\">'file'</span>,item.raw)</span><br><span class=\"line\">&#125;)        </span><br><span class=\"line\"><span class=\"keyword\">let</span> fetchOptionsForFile=&#123;</span><br><span class=\"line\">    method:<span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">    body:fileData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetch(<span class=\"string\">`<span class=\"subst\">$&#123;ipConfig&#125;</span>/api/Function/MFileImport`</span>,fetchOptionsForFile).then(<span class=\"function\"><span class=\"params\">response</span>=&gt;</span>response.json()).then(<span class=\"function\"><span class=\"params\">json</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(json);&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件列表上传\"><a href=\"#文件列表上传\" class=\"headerlink\" title=\"文件列表上传\"></a>文件列表上传</h2><p>通过选择文件夹，取得文件夹内的文件列表然后以POST FormData的方式进行上传。</p>\n<p>上传配置只需在<code>input type=file</code>加上<code>webkitdirectory</code>属性即可。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"fileList\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">webkitdirectory</span> <span class=\"attr\">v-on:change</span> =<span class=\"string\">\"uploadFileList\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>注:webkitdirectory属性目前仅支持webkit内核的浏览器。</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fileList = <span class=\"keyword\">this</span>.$refs.fileList.files</span><br></pre></td></tr></table></figure>\n<p>取得文件列表<code>fileList</code>后循环添加到<code>fileData</code>对象就行了。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2><p>后面再补充吧。</p>\n","text":"前言多文件上传项目之前采用的是element-ui官方的文件上传组件，但在实际开发的过程中，发现该组件虽然能够选择多个文件进行上传，但是却不能同时上传(文件只能发送一次http请求，上传一次)。<br>最后采用 POST FormData的方式进行上传。Fetch FormDat","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":2,"path":"api/tags/前端.json"},{"name":"fetch","slug":"fetch","count":1,"path":"api/tags/fetch.json"}]},{"title":"linux部署与nginx代理","slug":"linux部署与nginx代理","date":"2018-07-05T01:01:30.000Z","updated":"2018-07-10T06:48:14.422Z","comments":true,"path":"api/articles/linux部署与nginx代理.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>总结一下自己在linux(<code>以下以centos7.2为例</code>)下部署网站所遇到的问题以及感想。<code>(linux系统、nginx基本知识就不展开讲了)</code></p>\n<h3 id=\"静态网站部署\"><a href=\"#静态网站部署\" class=\"headerlink\" title=\"静态网站部署\"></a>静态网站部署</h3><ol>\n<li>安装好linux系统以及<code>vim</code>、<code>nginx</code>等等常用软件</li>\n<li>进入 <code>/etc/nginx/conf.d</code> 目录，一般会有个<code>default.conf</code>配置文件。以你的工程名新建一个<code>.conf文件</code>,内容同<code>default.conf</code>相同。</li>\n<li>配置<code>.conf</code>文件(详情配置说明见<a href=\"https://blog.csdn.net/u010320371/article/details/78995097\" target=\"_blank\" rel=\"noopener\">.conf</a>)</li>\n<li>location 配置(以<code>sell</code>工程为例)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /sell/ &#123;</span><br><span class=\"line\">  rewrite ^/server_name/sell/index.html  //server_name为你的IP或者域名</span><br><span class=\"line\">  root   /data/www;  //项目路径位置</span><br><span class=\"line\">  index  index.html index.htm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"nginx服务代理\"><a href=\"#nginx服务代理\" class=\"headerlink\" title=\"nginx服务代理\"></a>nginx服务代理</h3><blockquote>\n<p>以我之前的球球音乐为例</p>\n</blockquote>\n<ol>\n<li>安装node.js、pm2</li>\n<li>修改你前台请求node server地址为服务器的IP或者域名</li>\n<li>后面步骤与静态部署相同</li>\n<li>pm2启动express文件</li>\n<li>location配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /qqmusic/ &#123;</span><br><span class=\"line\">  rewrite ^/server_name/qqmusic/index.html  //server_name为你的IP或者域名</span><br><span class=\"line\">  proxy_set_header X-RealIP $remote_addr;</span><br><span class=\"line\">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">  proxy_set_header Host $http_host;</span><br><span class=\"line\">  proxy_set_header X-Nginx-Proxy true;</span><br><span class=\"line\">  proxy_pass http://127.0.0.1:4000/; // 这里的端口要和你的node服务端口相同</span><br><span class=\"line\">  root   /data/www;  //项目路径位置</span><br><span class=\"line\">  index  index.html index.htm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"以后再补充\"><a href=\"#以后再补充\" class=\"headerlink\" title=\"以后再补充\"></a>以后再补充</h3><h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言总结一下自己在linux(以下以centos7.2为例)下部署网站所遇到的问题以及感想。(linux系统、nginx基本知识就不展开讲了)静态网站部署安装好linux系统以及vim、nginx等等常用软件进入 /etc/nginx/conf.d 目录，一般会有个default","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"Nginx","slug":"Nginx","count":2,"path":"api/tags/Nginx.json"},{"name":"Node.js","slug":"Node-js","count":1,"path":"api/tags/Node-js.json"},{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}]},{"title":"JSONP抓取数据","slug":"jsonp","date":"2018-04-25T01:01:30.000Z","updated":"2018-06-26T01:28:28.468Z","comments":true,"path":"api/articles/jsonp.json","excerpt":"","keywords":null,"cover":"/img/jsonp/jsonp_axios.png","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近做自己个人项目(球球音乐PC端以及移动端)的时候，涉及到接口数据的抓取。<br>根据接口的特性,用到了jsonp的方式进行抓取，谈谈自己的总结吧。</p>\n<blockquote>\n<p>JSONP工作原理</p>\n</blockquote>\n<p>进行jsonp通信时,客户端会在其脚本上新建一个<code>&lt;script&gt;</code>元素,其src地址指向API接口地址。<br>例如:<code>&lt;script src=&quot;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt;</code><br>(加参数的话,可在链接后面直接加相应参数,也可在配置对象里面加),并且提供一个回调函数来接受JSON数据(可自行约定)。</p>\n<p>注:jsonp库我用的是node官方的jsonp包,地址<a href=\"https://www.npmjs.com/package/node-jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a></p>\n<h2 id=\"JSONP抓取\"><a href=\"#JSONP抓取\" class=\"headerlink\" title=\"JSONP抓取\"></a>JSONP抓取</h2><blockquote>\n<p>普通抓取(服务器不做限制)</p>\n</blockquote>\n<p>官方提供了三个列子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSONP(<span class=\"string\">'http://twitter.com/users/oscargodson.json'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(json)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">JSONP(<span class=\"string\">'http://api.flickr.com/services/feeds/photos_public.gne'</span>,&#123;<span class=\"string\">'id'</span>:<span class=\"string\">'12389944@N03'</span>,<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span>&#125;,<span class=\"string\">'jsoncallback'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(json)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">JSONP(<span class=\"string\">'http://graph.facebook.com/FacebookDevelopers'</span>, <span class=\"string\">'callback'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(json)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过Express代理\"><a href=\"#通过Express代理\" class=\"headerlink\" title=\"通过Express代理\"></a>通过Express代理</h2><blockquote>\n<p>通过Express代理</p>\n</blockquote>\n<p>由于jsonp是一种非正式传输协议，不同于XMLHttpRequest一样需要按照CORS规范,并且配置相应header头文件进行传输。<br>所以很多公司会对其API进行请求验证。以球球音乐为例,它会对请求header中的host以及referer进行验证,如图所示<br><img src=\"/img/jsonp/jsonp_axios.png\" alt=\"jsonp_axios\"></p>\n<p>so,看了imooc关于这方面的代码。</p>\n<p>最后以<code>express</code>框架做http中间代理转发前端请求,配置其header后再进行API的调用,以此方式来绕过host以及Referer验证,从而获取到数据。<br>配置代码如下:</p>\n<blockquote>\n<p>编译环境下</p>\n</blockquote>\n<p>vue工程的话,在<code>/build/webpack.dev.conf.js</code>中进行node server配置以及axios代理。<br>react工程的话,在其<code>webpack配置文件</code>中配置。</p>\n<blockquote>\n<p>线上环境在express配置文件下配置相应路由就行了</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先引入axios以及bodyParser</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> axios = <span class=\"built_in\">require</span>(<span class=\"string\">'axios'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: utils.styleLoaders(&#123;<span class=\"attr\">sourceMap</span>: config.dev.cssSourceMap, <span class=\"attr\">usePostCSS</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// cheap-module-eval-source-map is faster for development</span></span><br><span class=\"line\">  devtool: config.dev.devtool,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// these devServer options should be customized in /config/index.js</span></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    before(app) &#123;</span><br><span class=\"line\">\t  <span class=\"comment\">//bodyParser.urlencoded接收req.body,并对其进行解析。</span></span><br><span class=\"line\">      app.use(bodyParser.urlencoded(&#123;<span class=\"attr\">extended</span>: <span class=\"literal\">true</span>&#125;))</span><br><span class=\"line\">      app.get(<span class=\"string\">'/api/getDiscList'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> url = <span class=\"string\">'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'</span></span><br><span class=\"line\">        axios.get(url, &#123;</span><br><span class=\"line\">          headers: &#123;</span><br><span class=\"line\">            referer: <span class=\"string\">'https://c.y.qq.com/'</span>,</span><br><span class=\"line\">            host: <span class=\"string\">'c.y.qq.com'</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          params: req.query</span><br><span class=\"line\">        &#125;).then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          res.json(response.data)</span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>api/getDiscList.js</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDiscList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = <span class=\"string\">'/api/getDiscList'</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, commonParams, &#123;</span><br><span class=\"line\">    platform: <span class=\"string\">'yqq'</span>,</span><br><span class=\"line\">    hostUin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    sin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    ein: <span class=\"number\">29</span>,</span><br><span class=\"line\">    sortId: <span class=\"number\">5</span>,</span><br><span class=\"line\">    needNewCode: <span class=\"number\">0</span>,</span><br><span class=\"line\">    categoryId: <span class=\"number\">10000000</span>,</span><br><span class=\"line\">    rnd: <span class=\"built_in\">Math</span>.random(),</span><br><span class=\"line\">    format: <span class=\"string\">'json'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(url, &#123;</span><br><span class=\"line\">    params: data</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现原理:1.调用<code>getDiscList</code>方法。2.请求<code>Express</code>代理服务配置地址。3.通过回调函数返回数据。</p>\n<p>以上有错误的地方,或者不懂的地方,欢迎来我的微博给我留言。</p>\n<h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言最近做自己个人项目(球球音乐PC端以及移动端)的时候，涉及到接口数据的抓取。<br>根据接口的特性,用到了jsonp的方式进行抓取，谈谈自己的总结吧。JSONP工作原理进行jsonp通信时,客户端会在其脚本上新建一个&lt;script&gt;元素,其src地址指向API接口","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"axios","slug":"axios","count":1,"path":"api/tags/axios.json"},{"name":"jsonp","slug":"jsonp","count":1,"path":"api/tags/jsonp.json"},{"name":"node.js","slug":"node-js","count":1,"path":"api/tags/node-js.json"}]}]}