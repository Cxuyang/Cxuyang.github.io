{"name":"http","slug":"http","count":1,"postlist":[{"title":"HTTP随记","slug":"HTTP随记","date":"2018-11-23T01:01:30.000Z","updated":"2019-02-26T01:35:09.027Z","comments":true,"path":"api/articles/HTTP随记.json","excerpt":"","keywords":null,"cover":"/img/HTTP/request.png","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>基础知识回顾http篇</p>\n<h3 id=\"1-http协议基础及发展历史\"><a href=\"#1-http协议基础及发展历史\" class=\"headerlink\" title=\"1.http协议基础及发展历史\"></a>1.http协议基础及发展历史</h3><h4 id=\"1-1http发展历史\"><a href=\"#1-1http发展历史\" class=\"headerlink\" title=\"1.1http发展历史\"></a>1.1http发展历史</h4><h5 id=\"http-0-9\"><a href=\"#http-0-9\" class=\"headerlink\" title=\"http 0.9\"></a>http 0.9</h5><ol>\n<li>只有一个命令（GET）</li>\n<li>没有header等描述数据的信息</li>\n<li>服务器发送完毕,就关闭TCP连接</li>\n</ol>\n<h5 id=\"http-1-0\"><a href=\"#http-1-0\" class=\"headerlink\" title=\"http 1.0\"></a>http 1.0</h5><ol>\n<li>增加了很多命令(POST,PUT等)</li>\n<li>增加status code 和 header</li>\n<li>多字符集支持、多部分发送、权限、缓存等</li>\n</ol>\n<h5 id=\"http-1-1\"><a href=\"#http-1-1\" class=\"headerlink\" title=\"http 1.1\"></a>http 1.1</h5><ol>\n<li>支持了持久连接(http请求后可以不关闭tcp连接)</li>\n<li>Pipeline(在同一个tcp连接里可以支持多个http请求)</li>\n<li>增加host和其他一些命令</li>\n</ol>\n<h5 id=\"http-2-0-暂未普及\"><a href=\"#http-2-0-暂未普及\" class=\"headerlink\" title=\"http 2.0(暂未普及)\"></a>http 2.0(暂未普及)</h5><ol>\n<li>所有数据以二进制传输</li>\n<li>同一个连接里面发送多个请求不在需要按照顺序来</li>\n<li>头信息压缩以及推送等提高效率的功能(推送:服务器端主动向前端推送数据)</li>\n</ol>\n<h4 id=\"1-2http协议基础\"><a href=\"#1-2http协议基础\" class=\"headerlink\" title=\"1.2http协议基础\"></a>1.2http协议基础</h4><p><img src=\"/img/HTTP/request.png\" alt=\"requestProcess\"></p>\n<p><img src=\"/img/HTTP/model.png\" alt=\"model\"></p>\n<ol>\n<li>低三层<br>a. 物理层: 物理层主要作用是定义物理设备如何传输数据(网线,网卡,电脑等硬件)<br>b. 数据链路层: 数据链路层在通信的实体间建立数据链路链接<br>c. 网络层: 网络层为数据在节点之间传输创建逻辑链路(自己电脑与服务器间)</li>\n<li>传输层 (TCP IP)</li>\n<li>应用层（HTTP）</li>\n</ol>\n<h3 id=\"2-http的三次握手\"><a href=\"#2-http的三次握手\" class=\"headerlink\" title=\"2.http的三次握手\"></a>2.http的三次握手</h3><p><img src=\"/img/HTTP/shakehans.png\" alt=\"request\"><br>请求过程: 用户在客户端发起http请求 然后 建立tcp 连接 ，把请求发送给服务器端</p>\n<p><img src=\"/img/HTTP/shakehans1.png\" alt=\"shakehands\"></p>\n<ol>\n<li>客户端发送一个我要创建连接的数据包</li>\n<li>服务器端开放一个端口并返回给客户端带有标识的数据包</li>\n<li>客户端表示服务器端允许连接后再发送一个带有标识的数据包</li>\n</ol>\n<blockquote>\n<p>3次握手的目的</p>\n</blockquote>\n<p>防止服务器端开启一些无用的连接(规避网络原因等引起无用的一些端口开销和连接)</p>\n<h3 id=\"3-URI-URL-URN\"><a href=\"#3-URI-URL-URN\" class=\"headerlink\" title=\"3.URI URL URN\"></a>3.URI URL URN</h3><ol>\n<li>URI: 统一资源标识符（Uniform Resource Identifier，或URI)  用来唯一标识互联网上的信息资源</li>\n<li><p>URL：统一资源定位符（Uniform Resource Locator）http  ftp 等都是url</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符</span><br><span class=\"line\">b. 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</span><br><span class=\"line\">c. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</span><br><span class=\"line\">d. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</span><br><span class=\"line\">e. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</span><br><span class=\"line\">f.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</span><br><span class=\"line\">g.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>URN：永久统一资源定位符 在资源移动之后还能找到</p>\n</li>\n</ol>\n<h3 id=\"4-Cache-Control\"><a href=\"#4-Cache-Control\" class=\"headerlink\" title=\"4.Cache-Control\"></a>4.Cache-Control</h3><ol>\n<li>可缓冲性<br><code>Public</code>  http经过任何地方都可以缓存(服务器,代理服务器等)<br><code>Private</code> 发起请求的浏览器才可以进行缓存<br><code>No-cache</code> 可以服务器同意后才能使用缓存</li>\n<li>到期<br><code>Max-age=&lt;seconds&gt;</code>  缓存多少秒过期<br><code>s-maxage=&lt;seconds&gt;</code> 仅在代理服务器上设置的缓存到期时间<br><code>max-stale=&lt;seconds&gt;</code> 在设置的缓存过期时间后还能使用过期的缓存</li>\n<li>重新验证<br><code>Must-revalidate</code>  在缓存过期之后必须去服务器重新请求<br><code>Proxy-revalidate</code>  缓存服务器使用的</li>\n<li>其他<br><code>No-store</code>  本地和服务器都不能存储这个缓存<br><code>No-transform</code> 代理服务器用</li>\n</ol>\n<h3 id=\"5-资源验证-用于设置了no-cache的验证\"><a href=\"#5-资源验证-用于设置了no-cache的验证\" class=\"headerlink\" title=\"5.资源验证(用于设置了no-cache的验证)\"></a>5.资源验证(用于设置了no-cache的验证)</h3><blockquote>\n<p>验证头</p>\n<ol>\n<li>Last-Modified<br>上次修改时间<br>服务器端 使用<code>If-Modified-Since</code>或者<code>If-Unmodified-Since</code><br>对比上次修改时间以验证资源是否需要更新</li>\n<li>Etag<br>数据签名<br>服务器端 使用<code>If-Match</code>或者<code>If-Non-Match</code><br>对比资源的签名 判断是否使用缓存</li>\n</ol>\n</blockquote>\n<h3 id=\"6-Cookie\"><a href=\"#6-Cookie\" class=\"headerlink\" title=\"6.Cookie\"></a>6.Cookie</h3><p>通过Set-Cookie字段设置, 下次请求会自动带上, 以键值对,可以设置多个, <code>Cookie不等于session</code><br><code>属性</code></p>\n<ol>\n<li>Max-age(设置一个过期的时间, 比如几秒)和expires(设置一个具体的过期时间点)设置过期时间</li>\n<li>Secure只在https的时候发送</li>\n<li>HttpOnly无法通过documen.cookie访问(无法通过js获取)</li>\n</ol>\n<h3 id=\"7-http长链接-Connection-keep-alive-请求后不关闭tcp链接\"><a href=\"#7-http长链接-Connection-keep-alive-请求后不关闭tcp链接\" class=\"headerlink\" title=\"7.http长链接(Connection:keep-alive,请求后不关闭tcp链接)\"></a>7.http长链接(Connection:keep-alive,请求后不关闭tcp链接)</h3><ol>\n<li>设置后, 多个http请求共用一个tcp链接(chorme为最多支持6个并发的http请求)</li>\n<li>http2.0 支持一个tcp链接 可以多个http请求</li>\n</ol>\n<h3 id=\"8-数据协商-客服端发送请求-表明想要什么类型的数据\"><a href=\"#8-数据协商-客服端发送请求-表明想要什么类型的数据\" class=\"headerlink\" title=\"8.数据协商(客服端发送请求,表明想要什么类型的数据)\"></a>8.数据协商(客服端发送请求,表明想要什么类型的数据)</h3><blockquote>\n<p>请求</p>\n</blockquote>\n<ol>\n<li>Accept 想要的数据类型</li>\n<li>ACCEPT-Encoding  编码方式(压缩方式, gzip,deflate,br)</li>\n<li>Accept-Language  语言</li>\n<li>User-Agent  移动端或者PC端</li>\n<li>Content-Type  传送的数据格式</li>\n<li>…</li>\n</ol>\n<blockquote>\n<p>返回</p>\n</blockquote>\n<ol>\n<li>Content  服务器端返回的数据类型</li>\n<li>Content-Type  返回的数据格式</li>\n<li>Content-Encoding  返回的编码方式(压缩方式, gzip,deflate,br)</li>\n<li>Content-Language  返回的语言</li>\n<li>X-Content-Type-Options: nosniff   告诉浏览器不要猜测返回数据类型</li>\n<li>…</li>\n</ol>\n<p><img src=\"/img/HTTP/accept-content.png\" alt=\"accept-content\"></p>\n<h3 id=\"9-Redirect-重定向\"><a href=\"#9-Redirect-重定向\" class=\"headerlink\" title=\"9.Redirect(重定向)\"></a>9.Redirect(重定向)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (request.url === <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// stateCode(状态码): 301-永久重定向,清除浏览器缓存消失; 302-每次都会进入浏览器进行跳转</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> stateCode = <span class=\"string\">'301'</span></span><br><span class=\"line\">  response.writeHead(stateCode. &#123;</span><br><span class=\"line\">    <span class=\"string\">'Location'</span>: <span class=\"string\">'/new'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  response.end(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-Content-Security-Policy-内容安全策略\"><a href=\"#10-Content-Security-Policy-内容安全策略\" class=\"headerlink\" title=\"10.Content-Security-Policy(内容安全策略)\"></a>10.Content-Security-Policy(内容安全策略)</h3><ol>\n<li>限制资源获取</li>\n<li>报告资源获取越权</li>\n</ol>\n<blockquote>\n<p>限制方式</p>\n</blockquote>\n<ol>\n<li>default-src 限制全局</li>\n<li>限制指定资源类型(connect-src, img-srcm, script-src, style-src…)</li>\n</ol>\n<h3 id=\"以后再补充\"><a href=\"#以后再补充\" class=\"headerlink\" title=\"以后再补充\"></a>以后再补充</h3><h2 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h2>","text":"前言基础知识回顾http篇1.http协议基础及发展历史1.1http发展历史http 0.9只有一个命令（GET）没有header等描述数据的信息服务器发送完毕,就关闭TCP连接http 1.0增加了很多命令(POST,PUT等)增加status code 和 header多字","link":"","raw":null,"photos":[],"categories":[{"name":"前端","slug":"前端","count":6,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":2,"path":"api/tags/前端.json"},{"name":"http","slug":"http","count":1,"path":"api/tags/http.json"},{"name":"Nginx","slug":"Nginx","count":2,"path":"api/tags/Nginx.json"}]}]}